# 数据库事务有哪些特性 

1. **原子性（Atomicity）：**事务作为一个整体被执行 ，要么全部执行，要么全部不执行；
2. **一致性（Consistency）：**保证数据库状态从一个一致状态转变为另一个一致状态；
3. **隔离性（Isolation）：**多个事务并发执行时，一个事务的执行不应影响其他事务的执行；
4. **持久性（Durability）：**一个事务一旦提交，对数据库的修改应该永久保存 

#  脏读和幻读的区别是什么？  



#  可重复读的隔离级别下如何保证不幻读  

#  非关系型数据库和关系型数据库的区别  

#  Mysql mvcc？

#  乐观锁与悲观锁的区别

## 乐观锁

利用数据库的锁机制实现，在整个数据处理过程中都加入了锁，以保持排他性。

## 悲观锁

乐观锁可以利用CAS实现，在**操作数据**的时候进行一个比较，按照**当前事务中的数据和数据库表中的该数据是否一致**来决定是否要执行本次操作。	



#  数据库范式讲一下  

#  主键是什么？

#  内连接 左连接 右连接

#  union与union all的区别

#  Explain

#  最左前缀原则

在联合索引的情况下，不需要索引的全部定义，只要满足最左前缀，就可以利用索引来加快查询速度。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。最左前缀原则的利用也可以显著提高查询效率，是常见的MySQL性能优化手段。

#  B+树的结构？与二叉树的区别？与B树的区别？  

## 二叉树

1. 非叶子节点只能允许最多两个子节点存在。
2. 每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值。
3. 树的左右两边的层级数相差不会大于1;
4. 没有值相等重复的节点;

### 为什么底层数据结构不用二叉查找树。  

因为当进行全表扫描的时候，树的深度很深，会进行多次IO 开销很大，

## B树

<img src="/Users/jiangcheng/Library/Application Support/typora-user-images/截屏2020-03-08下午10.00.43.png" alt="截屏2020-03-08下午10.00.43" style="zoom:50%;" />

特点

1. 排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
2. 子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；
3. 关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);
4. 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;

## B+树

![截屏2020-03-09下午10.57.57](/Users/jiangcheng/Library/Application Support/typora-user-images/截屏2020-03-09下午10.57.57.png)

特点

1. 非叶子结点的子树指针与关键字个数相同
2. 非叶子结点的子树指针p[i]，指向关键字值[k[i],k[i+1]]的子树
3. 非叶子结点仅用来索引，数据都保存在叶子节点中
4. 所有叶子节点均有一个链指针指向下一个叶子节点

### B+树比B树更适合做存储索引原因

1. B+树磁盘读写代价更低
2. B+树查询效率更稳定
3. B+树更有利于对数据库扫描

#  Hash索引和 B+树索引优劣分析  

## Hash索引

### 优点 

1. 查询效率高

### 缺点 

1. 仅仅满足 “=”，“IN”,不能范围查询，比如where cost>50
5. 大量Hash值相等的情况，会发生hash冲突，存储引擎要遍历链表所有指针，逐行比较，直到找打符合条件的行。
3. 如果哈希冲突很多，则维护索引代价也很高。例如如果在某个哈希冲突很多地方建立索引，若要删除其中一行，则要遍历整个链表，逐行比较才能删除索引，冲突越多，代价越大。
4. 哈希索引数据不是按照索引值顺序存储，所以无法用于排序
5. 不支持部分索引列匹配查找，因为哈希索引是使用索引列全部内容来计算机哈希值，例如数据库(A,B,C)，如果只查询A，则无法使用该索引



## B+树索

### 优点

### 缺点

#  索引用B+树而不用红黑树？ 

#  数据库怎么优化

#  什么时候不该使用索引？  

#  聚集索引和非聚集索引的区别 

## 聚簇索引

称为主键索引，其索引树的叶子节点中存的是**整行数据**，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。因为索引（目录）只能按照一种方法进行排序。

### 优点

1. 数据访问更快，聚簇索引将索引和数据都保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
2. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

### 缺点

1. 聚簇索引最大限度提高IO 密集型应用性能，但是如果全部数据加载到内存，则访问顺序就不重要了，聚簇索引页没什么优势了
2. 插入速度严重依赖插入顺序。按照主键顺序插入是加载数据到InnoDB表中速度最快的方式。
3. 更新聚簇索引列代价很高，每次更新会强制InnoDb将每个被更新的行移动到新的位置。
4. 基于聚簇索引插入新行，可能会导致页分裂的问题。当行的主键插入到某个已满的页中，存储引擎会将该页分裂成两个页面容纳该行。页分裂会导致表占用更多的磁盘空间。
5. 聚簇索引可能导致全表扫描变慢，尤其行比较稀疏的时候。

## 非聚簇索引

非聚簇索引普通索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引。

* 二级索引访问需要两次索引查找

  这是因为二级索引保存的是行指针。该指针不是指向行的无力位置的指针，而是行的主键值。通过二级索引找到对应主键后，再根据这个主键去聚簇索引查找对应的行，所以有两次索引查找。

#  Mysql知道几种存储引擎，有什么区别 

## mysql的引擎

### MyISAM存储引擎 

不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表

### InnoDB存储引擎

 该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。
InnoDB存储引擎的特点：支持自动增长列，支持外键约束

### MEMORY存储引擎

Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。

### MERGE存储引擎

Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。

### 存储引擎有InnoDB和MyISAM的区别

1. MyISAM不支持事务；InnoDB是事务类型的存储引擎。
2. MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁。
3. MyISAM引擎不支持外键；InnoDB支持外键。
4. 对于count(*)查询来说MyISAM更有优势，因为其保存了行数。
5. InnoDB是为处理巨大数据量时的最大性能设计的存储引擎。
6. MyISAM支持全文索引（FULLTEXT）；InnoDB不支持。

#  覆盖索引 

如果在普通索引树上的查询已经直接提供了结果，不需要回表操作，这样的普通索引叫做覆盖索引。覆盖索引的使用可以显著提高查询效率，是常见的MySQL性能优化手段。

#  主从复制、读写分离、分库分表 

#  Mysql锁划分 

MySQL数据库的锁分为**表级锁和行级锁**。从数据库的角度看，行级锁又可以分为**独占锁和共享锁**。

### 独占锁

独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，**即INSERT、UPDATE 或DELETE 命令时，MySQL会自动使用独占锁**。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。

在select命令中使用独占锁的SQL语句为：**select … for update;**

### 共享锁

共享锁顾名思义，那就是其锁定的资源可以被其它用户读取，但其它用户不能修改。如果在select查询语句中要手动加入共享锁，那么对应的SQL语句为：**select ... lock in share mode**

#  Mysql架构 

1. **连接器：**验证客户端权限，建立和断开MySQL连接
2. **分析器：**进行SQL语句的语法分析
3. **优化器：**选择索引，生成具体的SQL语句执行计划
4. **执行器：**操作存储引擎，执行SQL，返回执行结果
5. **存储引擎层：**各个不同的存储引擎都提供了一些读写接口来操作数据库

#  in和exist区别

